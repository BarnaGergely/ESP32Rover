#if not defined(ESP32) && not defined(ESP8266)
Critical error : This program is ESP32 or ESP8266 only
#endif

#include <Arduino.h>
#include <DNSServer.h>
#ifdef ESP32
#include <AsyncTCP.h>
#include <WiFi.h>
#elif defined(ESP8266)
#include <ESP8266WiFi.h>
#include <ESPAsyncTCP.h>
#endif
#include <ArduinoJson.h>
#include <DRV8833.h>
#include <ESPAsyncWebServer.h>
#include <LedBlinker.h>
#include <LittleFS.h>
#include <index_html.h>  // Stores the web page as plain text. Generated by the build process.
// #include <index_html_gz.h>  // Stores the web page as gzip compressed binaries. Generated by the build process.

#define DEVELOPER_MODE  // Comment this line to disable debug logs and build the app in release mode

#ifdef DEVELOPER_MODE
#define DEBUGLOG_DEFAULT_LOG_LEVEL_DEBUG  // In debug mode, set the default log level to INFO in DebugLog library
#endif

#ifndef DEVELOPER_MODE
#define DEBUGLOG_DISABLE_LOG  // In release mode, disable all logs
#endif

#include <SimpleDebugLog.h>

#ifdef DEVELOPER_MODE
#define WOKWI  // In developer mode, turn on features for WokWi simulation
#endif

#define MOTOR_LEFT_PIN1 2
#define MOTOR_LEFT_PIN2 3
#define MOTOR_RIGHT_PIN1 4
#define MOTOR_RIGHT_PIN2 5

#define MOTOR_DRIVER_LEFT_INVERT false
#define MOTOR_DRIVER_RIGHT_INVERT false

#define MOTOR_DRIVER_MAX_PWM 127
#define MOTOR_DRIVER_MIN_PWM -127
#define MOTOR_DRIVER_RAMP_TIME 60
#define MOTOR_DRIVER_NEUTRAL_WIDTH 60
#define MOTOR_DRIVER_BRAKE false
#define MOTOR_DRIVER_NEUTRAL_BRAKE false
#include <MotorDriver.cpp>

#define WIFI_SSID "AwesomeRobot"
// You can remove the password parameter if you want the AP to be open.
// a valid password must have more than 7 characters
#define WIFI_PASSWORD "12345678"

                                              // Global variables:
                                              MotorDriver motorLeft(DRV8833(MOTOR_LEFT_PIN1, MOTOR_LEFT_PIN2, MOTOR_DRIVER_MIN_PWM, MOTOR_DRIVER_MAX_PWM,
                                                                            MOTOR_DRIVER_RAMP_TIME, MOTOR_DRIVER_BRAKE, MOTOR_DRIVER_NEUTRAL_BRAKE));
MotorDriver motorRight(DRV8833(MOTOR_RIGHT_PIN1, MOTOR_RIGHT_PIN2, MOTOR_DRIVER_MIN_PWM, MOTOR_DRIVER_MAX_PWM, MOTOR_DRIVER_RAMP_TIME, MOTOR_DRIVER_BRAKE,
                               MOTOR_DRIVER_NEUTRAL_BRAKE));

LedBlinker builtInLed = LedBlinker(LED_BUILTIN);

IPAddress myIP;
DNSServer dnsServer;
AsyncWebServer server(80);
AsyncWebSocket ws("/ws");

class CaptiveRequestHandler : public AsyncWebHandler {
   public:
    bool canHandle(__unused AsyncWebServerRequest *request) const override { return true; }

    // TODO: Customize this
    void handleRequest(AsyncWebServerRequest *request) {
        AsyncResponseStream *response = request->beginResponseStream("text/html");
        response->print("<!DOCTYPE html><html><head><title>Captive Portal</title></head><body>");
        response->print("<p>This is our captive portal front page.</p>");
        response->printf("<p>You were trying to reach: http://%s%s</p>", request->host().c_str(), request->url().c_str());
        response->print("</body></html>");
        request->send(response);
    }
};

// Function declarations:
int setupWifiAP();
int setupWokwiWifi();
int setupWifi();
int mapRestEndpoints();
void handleRootGetHttpRequest(AsyncWebServerRequest *request);
int setupWebServer();
void handleWebSocketMessage(void *arg, uint8_t *data, size_t len);
void onWebSocketEvent(AsyncWebSocket *server, AsyncWebSocketClient *client, AwsEventType type, void *arg, uint8_t *data, size_t len);
String processor(const String &var);
int setupWebSocketServer();

// Main program:
void setup() {
    // make sure the motors are turned off
    motorLeft.stop();
    motorRight.stop();

    Serial.begin(115200);
    delay(500);  // Give some time to connect to the serial monitor

    builtInLed.begin();
    builtInLed.blinkContinuously(200, 2000);

    if (setupWifi()) {
        LOG_ERROR("WiFi setup failed.");
    }

    if (setupWebServer()) {
        LOG_ERROR("Web server setup failed.");
    }

    if (setupWebSocketServer()) {
        LOG_ERROR("WebSocket server setup failed.");
    }

    server.begin();

#ifndef WOKWI
#ifdef ESP32
    if (!LittleFS.begin(true)) {
        LOG_ERROR("LittleFS Mount Failed");
    }
#else
    if (!LittleFS.begin()) {
        LOG_ERROR("LittleFS Mount Failed");
    }
#endif
#endif

    LOG_INFO("Setup completed, time: ", millis());
}

void loop() {
    builtInLed.run();
    ws.cleanupClients();
    // dnsServer.processNextRequest();
#ifdef WOKWI
    delay(10);  // this speeds up the WokWi simulation
#endif
}

// Function definitions:
int setupWifi() {
    // WOKWI not supports Access Points, so we need to connect its wifi if we are using it
#ifdef WOKWI
    return setupWokwiWifi();
#else
    return setupWifiAP();
#endif
}

int setupWifiAP() {
    LOG_INFO("Setting up WiFi Access Point");

    // Remove the password parameter, if you want the
    // AP (Access Point) to be open
    if (!WiFi.softAP(WIFI_SSID, WIFI_PASSWORD)) {
        LOG_ERROR("Soft AP creation failed.");
        LOG_ERROR("Boot stopped. Please restart the device manually.");
        while (1);
    }

    myIP = WiFi.softAPIP();
    LOG_INFO("Access Point IP address: ", myIP);

    return 0;
}

int setupWokwiWifi() {
    LOG_INFO("Connecting to virtual Wokwi WiFi");
    WiFi.begin("Wokwi-GUEST", "", 6);  // The WiFi channel 6 skips the WiFi scanning phase and saves about 4 seconds when connecting to the WiFi.
    while (WiFi.status() != WL_CONNECTED) {
        delay(100);
    }
    LOG_INFO("WiFi Connected!");
    return 0;
}

void handleRootGetHttpRequestWokwi(AsyncWebServerRequest *request) {
    LOG_INFO("Handling root GET HTTP request");
    LOG_INFO("Sending index.html:");
    AsyncWebServerResponse *response = request->beginResponse(200, "text/html", index_html);
    // response->addHeader("Content-Encoding", "gzip");
    request->send(response);
}

int setupWebServer() {
    LOG_INFO("Setting up web server");

    // by default the DNSServer is start serving any ("*") domain name.
    // It will reply Access Point's IP to all DNS request (this is required for Captive Portal detection)
    if (dnsServer.start(53, "*", WiFi.softAPIP())) {
        LOG_INFO("Started DNS server in captive portal-mode");
    } else {
        LOG_ERROR("Can't start DNS server!");
    }

    server.addHandler(new CaptiveRequestHandler()).setFilter(ON_AP_FILTER);  // only when requested from AP
#ifdef WOKWI
    // Wokwi simulator does not support file system so we need to serve the index.html as a variable in simulation,
    // but in variable the gzip compression is not supported or I don't know how to use it. Maybe this is the problem:
    // https://stackoverflow.com/questions/73118165/how-to-get-gzip-compression-as-string
    server.on("/", HTTP_GET, handleRootGetHttpRequestWokwi);
#else
    // This is not tested yet
    server.serveStatic("/", LittleFS, "/index.html.gz");
#endif
    server.onNotFound([](AsyncWebServerRequest *request) { request->send(404, "text/plain", "Not found"); });
    return 0;
}

void handleWebSocketMessage(void *arg, uint8_t *data, size_t len) {
    LOG_DEBUG("WebSocket message received");
    // Allocate the JSON document
    JsonDocument doc;

    // Deserialize the JSON document
    DeserializationError error = deserializeJson(doc, data, len);

    // Test if parsing succeeds
    if (error) {
        Serial.print(F("deserializeJson() failed: "));
        Serial.println(error.f_str());
        return;
    }

    // Handle the received data based on type
    if (doc["type"] == "joystick") {
        LOG_INFO("Joystick data received");
        LOG_INFO("  x: ", doc["x"].as<float>());
        LOG_INFO("  y: ", doc["y"].as<float>());

        // Map the joystick values to motor speeds

    } else if (doc["slider1"].as<int>() > 0) {
        LOG_INFO("Slider 1 data received");
        LOG_INFO("  Slider 1: ", doc["slider1"].as<int>());
    } else if (doc["slider2"].as<int>() > 0) {
        LOG_INFO("Slider 2 data received");
        LOG_INFO("  Slider 2: ", doc["slider2"].as<int>());
    } else if (doc["type"] == "switch") {
        LOG_INFO("Switch data received");
        LOG_INFO("  Switch ID: ", doc["id"].as<int>());
        LOG_INFO("  Value: ", doc["value"].as<int>());
    } else if (doc["type"] == "push") {
        LOG_INFO("Push button data received");
        LOG_INFO("  Push button ID: ", doc["id"].as<int>());
        LOG_INFO("  Value: ", doc["value"].as<int>());
    } else if (doc["type"] == "motor") {
        LOG_INFO("Motor data received");
        LOG_INFO("  Motor ID: ", doc["id"].as<String>()); // TODO: improve performance by using char[] instead of String
        LOG_INFO("  Value: ", doc["value"].as<int>());

        if (doc["id"] == "leftDrive") {
            motorLeft.setSpeed(doc["value"].as<int>());
        } else if (doc["id"] == "rightDrive") {
            motorRight.setSpeed(doc["value"].as<int>());
        }

    } else {
        LOG_INFO("Unknown data received");
    }
}

void onWebSocketEvent(AsyncWebSocket *server, AsyncWebSocketClient *client, AwsEventType type, void *arg, uint8_t *data, size_t len) {
    LOG_DEBUG("WebSocket event received");
    switch (type) {
        case WS_EVT_CONNECT:
            LOG_INFO("WebSocket client #", client->id());
            LOG_INFO("  connected from ", client->remoteIP().toString().c_str());
            break;
        case WS_EVT_DISCONNECT:
            LOG_INFO("WebSocket client disconnected: #", client->id());
            break;
        case WS_EVT_DATA:
            handleWebSocketMessage(arg, data, len);
            break;
        case WS_EVT_PING:
            LOG_INFO("Ping received");
            break;
        case WS_EVT_PONG:
            LOG_INFO("Pong received");
            break;
        case WS_EVT_ERROR:
            LOG_ERROR("WebSocket error");
            break;
    }
}

int setupWebSocketServer() {
    LOG_INFO("Setting up WebSocket server");
    ws.onEvent(onWebSocketEvent);
    server.addHandler(&ws);
    return 0;
}